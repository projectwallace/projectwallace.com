<script>
import BarChart from '$components/BarChart.svelte'
import { format_filesize } from '$lib/format-filesize'
import { format_number, format_percentage } from '$lib/format-number'
import Award from '$components/Award.svelte'
import Formula from '$components/Formula.svelte'
import Bar from '$components/stats/BarChart.svelte'
</script>

## Selectors

### Totals

Looking at the number of selectors in a stylesheet gives us a quick look into the magnitude of things.

<BarChart
title="Distribution of percentiles of total CSS selectors per website"
data={{
  "p10": 272,
  "p25": 1391,
  "p50": 3660,
  "p75": 7335,
  "p90": 12607,
}}
/>

From my experience analyzing websites I expected the p90 and p75 to be a lot higher. I'm actually quite pleased with this distribution. Also, the top 10% of websites apparently have only 272 selectors or less which is also surprising. This seems like a really low number to me.

### Pseudo classes

One concept that I blatantly stole from the Web Almanac is their overview of popular pseudo classes. It offers an interesting look into adopoption of newer pseudo classes and proportional use between classes.

<Bar
items={[
["hover", 95.24414140606254],
["where", 90.56326481644406],
["focus", 88.56574422138686],
["before", 87.58397984483723],
["after", 86.99112213068864],
["not", 86.39226585619451],
["last-child", 85.96236903143244],
["first-child", 85.7644165400304],
["active", 83.93485563464769],
["root", 79.13600735823402],
["nth-child", 76.8155642645765],
["disabled", 58.83487962888907],
["empty", 58.765896184915626],
["checked", 58.53695113172839],
["last-of-type", 57.3212429017036],
["visited", 54.645884987602976],
["nth-of-type", 53.18523554346957],
["first-of-type", 52.96928737103095],
["focus-visible", 48.19943213628729],
["-ms-input-placeholder", 44.095417099896025],
["has", 41.29908821882748],
["focus-within", 41.023154442933695],
["only-child", 36.971126929536915],
["is", 36.310285531472445],
["nth-last-child", 34.47372630568664],
["-moz-focusring", 32.99408142045909],
["-moz-placeholder", 25.675837798928256],
["link", 25.636847156682396],
["first-letter", 22.689554506918338],
["invalid", 21.419859233783892],
["host", 19.002439414540508],
["indeterminate", 18.312604974806046],
["-webkit-autofill", 17.039910421498842],
["valid", 16.495041190114375],
["placeholder-shown", 13.633727905302727],
["lang", 11.203311205310726],
["-moz-ui-invalid", 9.309765656242503],
["target", 6.109533711909141],
["-moz-placeholder-shown", 5.917579780852596],
["nth-last-of-type", 4.414940414300568],
["-webkit-full-screen", 3.7730944573302407],
["enabled", 3.602135487483004],
["fullscreen", 3.589138606734384],
["required", 2.788330800607854],
["read-only", 2.531392465808206],
["only-of-type", 2.5003999040230345],
].map(([value, count]) => ({value, count: count / 100}))}
context="",
enable_keyboard_navigation={false}
node_type="rule"
column_headers={['Pseudo class', 'Adoption %']}
/>

The 2022 Almanac listed `:hover`, `:focus` and `:active` as their top 3 but look at this: `:where` made it into the top 3! It has been Baseline available since January 2021 but this would be a good time to give yourself a pat on the back if you are a spec writer or part of the CSS Working Group. And while you're patting: `:has` is used on 41% percent of websites (Baseline December 2023). That's even higher than `:is` clocking in at 36% (also baseline January 2021). It would be interesting to see if the use of `:matches` and `:any` will go down as we use `:is` more. Regardless, these look like rock solid adoption rates if you ask me. We know that adoption of CSS features usually takes a bit and seeing these new-ish ones up there makes you proud of the language.

Looking further down the list we see `:empty` being used on 58% of websites. I find that surprising because I found it useful only on a handful of occasions.

<aside>
<p>Don't mind the <code>:before</code> and <code>:after</code> in this list. They get marked as pseudo classes even though they're actually pseudo elements. For backwards compatibility resons browsers allow you to write them with a single colon instead of two and most CSS minifiers omit the optional colon.</p>
</aside>

### Accessibility

Accessibility selectors are attribute selectors that check for the presence of `[aria-*]` and `[role=*]`. These are interesting because they tell a little bit about how accessibility is baked into the CSS. It's never the complete story but it's interesting nonetheless.

<BarChart
title="Distribution of accessibility selectors per website"
data={{
  "p10": 0,
  "p25": 0,
  "p50": 1,
  "p75": 6,
  "p90": 21,
}}
/>

Based on my own experience I find this number quite low. Most projects I've worked on have many more accessibility-focused selectors than this. Either everyone is setting their styles via regular class names (very valid) or we're not focusing on accessibility that much.

<!-- Ratio is 0 across all percentiles. -->

### Vendor prefixes

Vendor prefixed selectors are usually taken care of by CSS toolchains where they take your modern authored CSS and add some prefixes where necessary based on the required browser support.

<BarChart
title="Distribution of total prefixed selectors per website"
data={{
  "p10": 0,
  "p25": 7,
  "p50": 21,
  "p75": 47,
  "p90": 84,
}}
/>

Data shows that there's not that many vendor prefixed selectors per website and I'm curious to see if that number will go down in coming years as some of them will become obsolete. But on the other hand, some browser makers are shipping _new_ vendor prefixed selectors so we might be seeing these for years and years to come.

### Specificity

TODO

### Selector complexity

Most common selector complexity per website:

<BarChart
title="Distribution of percentiles of most common CSS selector complexity per website"
data={{
  "p10": 1,
  "p25": 1,
  "p50": 1,
  "p75": 2,
  "p90": 3,
}}
/>

Most selectors on most sites are simple selectors: only 1 or 2 parts to them. But what about the most complex selectors on any site?

<BarChart
title="Distribution of percentiles of maximum CSS selector complexity per website"
data={{
  "p10": 8,
  "p25": 12,
  "p50": 16,
  "p75": 22,
  "p90": 29,
}}
/>

A different picture. Even simple websites sometimes need more complex selectors to express more complex state.

<Award size={format_number(8804)}>
	If we would display this selector with {format_number(8804)} complexity this page would probably crash. So let's not do that. But beware of this beast in the wild.
</Award>

### Combinators

Selector combinators let you define relationships between your selectors. We often use the descendant combinator without thinking about it, but what about the others?

<BarChart
title="Distribution of percentiles of total CSS atrules per website"
data={{
  "(descendant)": 96.19591298088459 / 100,
  "> (child)": 90.23134447732544 / 100,
  "+ (adjecent sibling)": 81.9373350395905 / 100,
  "~ (general sibling)": 67.68475565864193 / 100,
}}
formatter={format_percentage}
/>

As expected the descendant combinator takes the top spot but the child combinator (`>`) is a close second. The other two are a bit below that and for me that makes sense. That seems to align with how I write CSS myself.
